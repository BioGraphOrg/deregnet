\hypertarget{classderegnet_1_1LazyConstraintCallbackRoot}{}\section{deregnet\+:\+:Lazy\+Constraint\+Callback\+Root Class Reference}
\label{classderegnet_1_1LazyConstraintCallbackRoot}\index{deregnet\+::\+Lazy\+Constraint\+Callback\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+Root}}


Implementation of the callback when there is a fixed root.  




{\ttfamily \#include $<$Lazy\+Constraint\+Callback.\+hpp$>$}



Inheritance diagram for deregnet\+:\+:Lazy\+Constraint\+Callback\+Root\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=206pt]{classderegnet_1_1LazyConstraintCallbackRoot__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for deregnet\+:\+:Lazy\+Constraint\+Callback\+Root\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=206pt]{classderegnet_1_1LazyConstraintCallbackRoot__coll__graph}
\end{center}
\end{figure}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classderegnet_1_1LazyConstraintCallbackRoot_afae052e08a40da4a0af8b35887b8715e}{get\+\_\+solution\+\_\+filter} (\hyperlink{namespacederegnet_a50db1f8fc7c6a954d825d9e1ed9ad302}{Node\+Filter} \&solution\+\_\+filter) override
\begin{DoxyCompactList}\small\item\em Figure out the nodes in the current subgraph. \end{DoxyCompactList}\item 
virtual void \hyperlink{classderegnet_1_1LazyConstraintCallbackRoot_a8cfcc3df75b7a06a9885c7f6c5286344}{set\+\_\+lazy\+\_\+constraint} (const std\+::set$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node} $>$ \&component, const std\+::set$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node} $>$ \&global\+\_\+parents) override
\begin{DoxyCompactList}\small\item\em Add lazy constraints to model. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Implementation of the callback when there is a fixed root. 

Definition at line 169 of file Lazy\+Constraint\+Callback.\+hpp.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classderegnet_1_1LazyConstraintCallbackRoot_afae052e08a40da4a0af8b35887b8715e}\label{classderegnet_1_1LazyConstraintCallbackRoot_afae052e08a40da4a0af8b35887b8715e}} 
\index{deregnet\+::\+Lazy\+Constraint\+Callback\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+Root}!get\+\_\+solution\+\_\+filter@{get\+\_\+solution\+\_\+filter}}
\index{get\+\_\+solution\+\_\+filter@{get\+\_\+solution\+\_\+filter}!deregnet\+::\+Lazy\+Constraint\+Callback\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+Root}}
\subsubsection{\texorpdfstring{get\+\_\+solution\+\_\+filter()}{get\_solution\_filter()}}
{\footnotesize\ttfamily void deregnet\+::\+Lazy\+Constraint\+Callback\+Root\+::get\+\_\+solution\+\_\+filter (\begin{DoxyParamCaption}\item[{\hyperlink{namespacederegnet_a50db1f8fc7c6a954d825d9e1ed9ad302}{Node\+Filter} \&}]{solution\+\_\+filter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}



Figure out the nodes in the current subgraph. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em solution\+\_\+filter} & Node mapping indicating whether a node belongs to the current solution \\
\hline
\end{DoxyParams}


Implements \hyperlink{classderegnet_1_1LazyConstraintCallback_aebc9854e98523c99d3f856ff71bb86fb}{deregnet\+::\+Lazy\+Constraint\+Callback}.



Definition at line 152 of file Lazy\+Constraint\+Callback.\+cpp.



References deregnet\+::\+Lazy\+Constraint\+Callback\+::graph, I\+N\+V\+A\+L\+ID, deregnet\+::\+Lazy\+Constraint\+Callback\+::selected\+\_\+nodes, and deregnet\+::\+Lazy\+Constraint\+Callback\+::x.


\begin{DoxyCode}
152                                                                                 \{
153     \textcolor{keywordflow}{for} (\hyperlink{namespacederegnet_ac34314e1b5f456fc6d1bb9d96316de4a}{NodeIt} v(*\hyperlink{classderegnet_1_1LazyConstraintCallback_af481c9d68dea2dab035e1f2f79cda4d5}{graph}); v != \hyperlink{usinglemon_8hpp_adf770fe2eec438e3758ffe905dbae208}{INVALID}; ++v) \{
154         \textcolor{keywordflow}{if} (getSolution((*\hyperlink{classderegnet_1_1LazyConstraintCallback_a48d0e4065232a6dca6e10fe416be755f}{x})[v]) >= 0.98) \{
155             solution\_filter[v] = \textcolor{keyword}{true};
156             \hyperlink{classderegnet_1_1LazyConstraintCallback_a5ddc4662e6e5c9f1d191c15edbefaa9b}{selected\_nodes}.push\_back(v);
157         \}
158         \textcolor{keywordflow}{else}
159             solution\_filter[v] = \textcolor{keyword}{false};
160     \}
161 \}
\end{DoxyCode}
\mbox{\Hypertarget{classderegnet_1_1LazyConstraintCallbackRoot_a8cfcc3df75b7a06a9885c7f6c5286344}\label{classderegnet_1_1LazyConstraintCallbackRoot_a8cfcc3df75b7a06a9885c7f6c5286344}} 
\index{deregnet\+::\+Lazy\+Constraint\+Callback\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+Root}!set\+\_\+lazy\+\_\+constraint@{set\+\_\+lazy\+\_\+constraint}}
\index{set\+\_\+lazy\+\_\+constraint@{set\+\_\+lazy\+\_\+constraint}!deregnet\+::\+Lazy\+Constraint\+Callback\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+Root}}
\subsubsection{\texorpdfstring{set\+\_\+lazy\+\_\+constraint()}{set\_lazy\_constraint()}}
{\footnotesize\ttfamily void deregnet\+::\+Lazy\+Constraint\+Callback\+Root\+::set\+\_\+lazy\+\_\+constraint (\begin{DoxyParamCaption}\item[{const std\+::set$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node} $>$ \&}]{component,  }\item[{const std\+::set$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node} $>$ \&}]{global\+\_\+parents }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}



Add lazy constraints to model. 

Given a solution $G'=(V',E') \subset G=(V,E)$ and a strong component $S \subset V'$ such that for all nodes $u \in V' \backslash S $, if $(u,v) \in E'$ then $v \notin S$, we add the following lazy constraint to the model\+: \[ \begin{equation} \displaystyle \sum_{v \in S} x_v - \displaystyle \sum_{u \in N^{-}(S)} x_u \leq |S| - 1 \end{equation} \] Here, $N^{-}(S) = \{v \in V \backslash S: \exists u \in S: (v,u) \in E \} $ are the global (incoming) parents of the component $S$.


\begin{DoxyParams}{Parameters}
{\em component} & An strong component of the solution not reachable from other nodes of the solution \\
\hline
{\em global\+\_\+parents} & All nodes not in the component which have a an edge towards a node from the component \\
\hline
\end{DoxyParams}


Implements \hyperlink{classderegnet_1_1LazyConstraintCallback_a8f6db7da84271afcd2e2169318569558}{deregnet\+::\+Lazy\+Constraint\+Callback}.



Definition at line 163 of file Lazy\+Constraint\+Callback.\+cpp.


\begin{DoxyCode}
164                                                                                          \{
165     GRBLinExpr component\_expr;
166     GRBLinExpr global\_parents\_expr;
167     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} v : component)
168         component\_expr += (*x)[v];
169     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} v : global\_parents)
170         global\_parents\_expr += (*x)[v];
171     GRBLinExpr lazy\_constr\_lhs = component\_expr - global\_parents\_expr;
172     \textcolor{keywordtype}{int} comp\_size = component.size();
173     addLazy(lazy\_constr\_lhs <= comp\_size - 1);
174 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/datadisk/bbubu/home/self/bbubu/projects/deregnet/src/\hyperlink{LazyConstraintCallback_8hpp}{Lazy\+Constraint\+Callback.\+hpp}\item 
/datadisk/bbubu/home/self/bbubu/projects/deregnet/src/\hyperlink{LazyConstraintCallback_8cpp}{Lazy\+Constraint\+Callback.\+cpp}\end{DoxyCompactItemize}
