\hypertarget{classderegnet_1_1LazyConstraintCallbackNoRoot}{}\section{deregnet\+:\+:Lazy\+Constraint\+Callback\+No\+Root Class Reference}
\label{classderegnet_1_1LazyConstraintCallbackNoRoot}\index{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root}}


Implementation of the callback when there is no fixed root.  




{\ttfamily \#include $<$Lazy\+Constraint\+Callback.\+hpp$>$}



Inheritance diagram for deregnet\+:\+:Lazy\+Constraint\+Callback\+No\+Root\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=206pt]{classderegnet_1_1LazyConstraintCallbackNoRoot__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for deregnet\+:\+:Lazy\+Constraint\+Callback\+No\+Root\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=206pt]{classderegnet_1_1LazyConstraintCallbackNoRoot__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classderegnet_1_1LazyConstraintCallbackNoRoot_abd4603bff30a09c920cdf67d8e5ba12f}{Lazy\+Constraint\+Callback\+No\+Root} (std\+::map$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node}, G\+R\+B\+Var $>$ $\ast$xx, std\+::map$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node}, G\+R\+B\+Var $>$ $\ast$yy, \hyperlink{namespacederegnet_a55b76c55bbabc682cbc61f8b9948799e}{Graph} $\ast$xgraph, double $\ast$xgap\+\_\+cut)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classderegnet_1_1LazyConstraintCallbackNoRoot_a80686ee58b84bb1c73af6f7eddb50db6}{get\+\_\+solution\+\_\+filter} (\hyperlink{namespacederegnet_a50db1f8fc7c6a954d825d9e1ed9ad302}{Node\+Filter} \&solution\+\_\+filter) override
\begin{DoxyCompactList}\small\item\em Figure out the current nodes in the subgraph and the identity of the root. \end{DoxyCompactList}\item 
virtual void \hyperlink{classderegnet_1_1LazyConstraintCallbackNoRoot_a3703cd9ca73c46d70bb90f50bb2e66e5}{set\+\_\+lazy\+\_\+constraint} (const std\+::set$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node} $>$ \&component, const std\+::set$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node} $>$ \&global\+\_\+parents) override
\begin{DoxyCompactList}\small\item\em Add lazy constraints to model. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::map$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node}, G\+R\+B\+Var $>$ $\ast$ \hyperlink{classderegnet_1_1LazyConstraintCallbackNoRoot_aaa32cd3d5b65d1c41174cbc9a120ab64}{y}
\begin{DoxyCompactList}\small\item\em Mapping from graph nodes to root indicator variables. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Implementation of the callback when there is no fixed root. 

Definition at line 212 of file Lazy\+Constraint\+Callback.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classderegnet_1_1LazyConstraintCallbackNoRoot_abd4603bff30a09c920cdf67d8e5ba12f}\label{classderegnet_1_1LazyConstraintCallbackNoRoot_abd4603bff30a09c920cdf67d8e5ba12f}} 
\index{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root}!Lazy\+Constraint\+Callback\+No\+Root@{Lazy\+Constraint\+Callback\+No\+Root}}
\index{Lazy\+Constraint\+Callback\+No\+Root@{Lazy\+Constraint\+Callback\+No\+Root}!deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root}}
\subsubsection{\texorpdfstring{Lazy\+Constraint\+Callback\+No\+Root()}{LazyConstraintCallbackNoRoot()}}
{\footnotesize\ttfamily deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root\+::\+Lazy\+Constraint\+Callback\+No\+Root (\begin{DoxyParamCaption}\item[{std\+::map$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node}, G\+R\+B\+Var $>$ $\ast$}]{xx,  }\item[{std\+::map$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node}, G\+R\+B\+Var $>$ $\ast$}]{yy,  }\item[{\hyperlink{namespacederegnet_a55b76c55bbabc682cbc61f8b9948799e}{Graph} $\ast$}]{xgraph,  }\item[{double $\ast$}]{xgap\+\_\+cut }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em xx} & \\
\hline
{\em yy} & \\
\hline
{\em xgraph} & \\
\hline
{\em xgap\+\_\+cut} & \\
\hline
\end{DoxyParams}


Definition at line 179 of file Lazy\+Constraint\+Callback.\+cpp.


\begin{DoxyCode}
183  : \hyperlink{classderegnet_1_1LazyConstraintCallback_ad025c982974ffc3e70677948b9668600}{LazyConstraintCallback}(xx, xgraph, \textcolor{keyword}{nullptr}, \hyperlink{classderegnet_1_1LazyConstraintCallback_a6a139307165523fa944e393e01aeec47}{gap\_cut}),
184    \hyperlink{classderegnet_1_1LazyConstraintCallbackNoRoot_aaa32cd3d5b65d1c41174cbc9a120ab64}{y} \{ yy \}
185 \{ \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classderegnet_1_1LazyConstraintCallbackNoRoot_a80686ee58b84bb1c73af6f7eddb50db6}\label{classderegnet_1_1LazyConstraintCallbackNoRoot_a80686ee58b84bb1c73af6f7eddb50db6}} 
\index{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root}!get\+\_\+solution\+\_\+filter@{get\+\_\+solution\+\_\+filter}}
\index{get\+\_\+solution\+\_\+filter@{get\+\_\+solution\+\_\+filter}!deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root}}
\subsubsection{\texorpdfstring{get\+\_\+solution\+\_\+filter()}{get\_solution\_filter()}}
{\footnotesize\ttfamily void deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root\+::get\+\_\+solution\+\_\+filter (\begin{DoxyParamCaption}\item[{\hyperlink{namespacederegnet_a50db1f8fc7c6a954d825d9e1ed9ad302}{Node\+Filter} \&}]{solution\+\_\+filter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}



Figure out the current nodes in the subgraph and the identity of the root. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em solution\+\_\+filter} & Node mapping indicating whether a node belongs to the current solution \\
\hline
\end{DoxyParams}


Implements \hyperlink{classderegnet_1_1LazyConstraintCallback_aebc9854e98523c99d3f856ff71bb86fb}{deregnet\+::\+Lazy\+Constraint\+Callback}.



Definition at line 189 of file Lazy\+Constraint\+Callback.\+cpp.



References deregnet\+::\+Lazy\+Constraint\+Callback\+::graph, I\+N\+V\+A\+L\+ID, deregnet\+::\+Lazy\+Constraint\+Callback\+::root, deregnet\+::\+Lazy\+Constraint\+Callback\+::selected\+\_\+nodes, deregnet\+::\+Lazy\+Constraint\+Callback\+::x, and y.


\begin{DoxyCode}
189                                                                                   \{
190     \textcolor{keywordflow}{for} (\hyperlink{namespacederegnet_ac34314e1b5f456fc6d1bb9d96316de4a}{NodeIt} v(*\hyperlink{classderegnet_1_1LazyConstraintCallback_af481c9d68dea2dab035e1f2f79cda4d5}{graph}); v != \hyperlink{usinglemon_8hpp_adf770fe2eec438e3758ffe905dbae208}{INVALID}; ++v) \{
191         \textcolor{keywordflow}{if} (getSolution((*\hyperlink{classderegnet_1_1LazyConstraintCallback_a48d0e4065232a6dca6e10fe416be755f}{x})[v]) >= 0.98) \{
192             solution\_filter[v] = \textcolor{keyword}{true};
193             \hyperlink{classderegnet_1_1LazyConstraintCallback_a5ddc4662e6e5c9f1d191c15edbefaa9b}{selected\_nodes}.push\_back(v);
194             \textcolor{keywordflow}{if} (getSolution((*\hyperlink{classderegnet_1_1LazyConstraintCallbackNoRoot_aaa32cd3d5b65d1c41174cbc9a120ab64}{y})[v]) >= 0.98)
195                 \hyperlink{classderegnet_1_1LazyConstraintCallback_aa4df18debaaf3aaace54a48b0c3e56ca}{root} = &\hyperlink{classderegnet_1_1LazyConstraintCallback_a5ddc4662e6e5c9f1d191c15edbefaa9b}{selected\_nodes}.back();
196         \}
197         \textcolor{keywordflow}{else}
198             solution\_filter[v] = \textcolor{keyword}{false};
199     \}
200 \}
\end{DoxyCode}
\mbox{\Hypertarget{classderegnet_1_1LazyConstraintCallbackNoRoot_a3703cd9ca73c46d70bb90f50bb2e66e5}\label{classderegnet_1_1LazyConstraintCallbackNoRoot_a3703cd9ca73c46d70bb90f50bb2e66e5}} 
\index{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root}!set\+\_\+lazy\+\_\+constraint@{set\+\_\+lazy\+\_\+constraint}}
\index{set\+\_\+lazy\+\_\+constraint@{set\+\_\+lazy\+\_\+constraint}!deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root}}
\subsubsection{\texorpdfstring{set\+\_\+lazy\+\_\+constraint()}{set\_lazy\_constraint()}}
{\footnotesize\ttfamily void deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root\+::set\+\_\+lazy\+\_\+constraint (\begin{DoxyParamCaption}\item[{const std\+::set$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node} $>$ \&}]{component,  }\item[{const std\+::set$<$ \hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node} $>$ \&}]{global\+\_\+parents }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}



Add lazy constraints to model. 

Given a solution $G'=(V',E') \subset G=(V,E)$ and a strong component $S \subset V'$ such that for all nodes $u \in V' \backslash S $, if $(u,v) \in E'$ then $v \notin S$, we add the following lazy constraints to the model\+: \[ \begin{equation} \displaystyle \sum_{v \in S} (x_v - y_v) - \displaystyle \sum_{u \in N^{-}(S)} x_u \leq |S| - 1 \end{equation} \] Here, $N^{-}(S) = \{v \in V \backslash S: \exists u \in S: (v,u) \in E \} $ are the global (incoming) parents of the component $S$.


\begin{DoxyParams}{Parameters}
{\em component} & An strong component of the solution not reachable from other nodes of the solution \\
\hline
{\em global\+\_\+parents} & All nodes not in the component which have a an edge towards a node from the component \\
\hline
\end{DoxyParams}


Implements \hyperlink{classderegnet_1_1LazyConstraintCallback_a8f6db7da84271afcd2e2169318569558}{deregnet\+::\+Lazy\+Constraint\+Callback}.



Definition at line 203 of file Lazy\+Constraint\+Callback.\+cpp.


\begin{DoxyCode}
204                                                                                            \{
205     GRBLinExpr component\_expr;
206     GRBLinExpr global\_parents\_expr;
207     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} v : component)                      \textcolor{comment}{// void build\_component\_expr(GRBLinExpr& expr); ...}
208         component\_expr += (*x)[v] - (*y)[v];
209     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} v : global\_parents)
210         global\_parents\_expr += (*x)[v];
211     GRBLinExpr lazy\_constr\_lhs = component\_expr - global\_parents\_expr;
212     \textcolor{keywordtype}{int} comp\_size = component.size();
213     addLazy(lazy\_constr\_lhs <= comp\_size - 1);
214 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classderegnet_1_1LazyConstraintCallbackNoRoot_aaa32cd3d5b65d1c41174cbc9a120ab64}\label{classderegnet_1_1LazyConstraintCallbackNoRoot_aaa32cd3d5b65d1c41174cbc9a120ab64}} 
\index{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root}!y@{y}}
\index{y@{y}!deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root@{deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root}}
\subsubsection{\texorpdfstring{y}{y}}
{\footnotesize\ttfamily std\+::map$<$\hyperlink{namespacederegnet_a744bad34f2de9856d36715a445f027f3}{Node}, G\+R\+B\+Var$>$$\ast$ deregnet\+::\+Lazy\+Constraint\+Callback\+No\+Root\+::y\hspace{0.3cm}{\ttfamily [private]}}



Mapping from graph nodes to root indicator variables. 



Definition at line 231 of file Lazy\+Constraint\+Callback.\+hpp.



Referenced by get\+\_\+solution\+\_\+filter().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/datadisk/bbubu/home/self/bbubu/projects/deregnet/src/\hyperlink{LazyConstraintCallback_8hpp}{Lazy\+Constraint\+Callback.\+hpp}\item 
/datadisk/bbubu/home/self/bbubu/projects/deregnet/src/\hyperlink{LazyConstraintCallback_8cpp}{Lazy\+Constraint\+Callback.\+cpp}\end{DoxyCompactItemize}
